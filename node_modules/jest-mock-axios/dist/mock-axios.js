"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _jestMockPromise = _interopRequireDefault(require("jest-mock-promise"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * TypeScript version of Axios mock for unit testing with [Jest](https://facebook.github.io/jest/).
 * This file is based on https://gist.github.com/tux4/36006a1859323f779ab0
 *
 * @author   knee-cola <nikola.derezic@gmail.com>
 * @license  @license MIT License, http://www.opensource.org/licenses/MIT
 */

/** a FIFO queue of pending request */
var _pending_requests = [];

var _newReq = function _newReq(url, data, config) {
  var promise = new _jestMockPromise.default();

  _pending_requests.push({
    config: config,
    data: data,
    promise: promise,
    url: url
  });

  return promise;
};

var MockAxios = jest.fn(_newReq); // mocking Axios methods

MockAxios.get = jest.fn(_newReq);
MockAxios.post = jest.fn(_newReq);
MockAxios.put = jest.fn(_newReq);
MockAxios.patch = jest.fn(_newReq);
MockAxios.delete = jest.fn(_newReq);
MockAxios.all = jest.fn(function (values) {
  return Promise.all(values);
});
MockAxios.head = jest.fn(_newReq);
MockAxios.options = jest.fn(_newReq);
MockAxios.create = jest.fn(function () {
  return MockAxios;
});
MockAxios.interceptors = {
  request: {
    use: jest.fn()
  },
  response: {
    use: jest.fn()
  }
};

MockAxios.popPromise = function (promise) {
  if (promise) {
    // remove the promise from pending queue
    for (var ix = 0; ix < _pending_requests.length; ix++) {
      var req = _pending_requests[ix];

      if (req.promise === promise) {
        _pending_requests.splice(ix, 1);

        return req.promise;
      }
    }
  } else {
    // take the oldest promise
    var _req = _pending_requests.shift();

    return _req ? _req.promise : void 0;
  }
};

MockAxios.popRequest = function (request) {
  if (request) {
    var ix = _pending_requests.indexOf(request);

    if (ix === -1) {
      return void 0;
    }

    _pending_requests.splice(ix, 1);

    return request;
  } else {
    return _pending_requests.shift();
  }
};
/**
 * Removes an item form the queue, based on it's type
 * @param queueItem
 */


var popQueueItem = function popQueueItem() {
  var queueItem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  // first le't pretend the param is a queue item
  var request = MockAxios.popRequest(queueItem);

  if (request) {
    // IF the request was found
    return request.promise;
  } else {
    // ELSE maybe the `queueItem` is a promise (legacy mode)
    return MockAxios.popPromise(queueItem);
  }
};

MockAxios.mockResponse = function (response) {
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  // replacing missing data with default values
  response = Object.assign({
    config: {},
    data: {},
    headers: {},
    status: 200,
    statusText: "OK"
  }, response); // resolving the Promise with the given response data

  popQueueItem(queueItem).resolve(response);
};

MockAxios.mockError = function () {
  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  // resolving the Promise with the given response data
  popQueueItem(queueItem).reject(Object.assign({}, error));
};

MockAxios.lastReqGet = function () {
  return _pending_requests[_pending_requests.length - 1];
};

MockAxios.lastPromiseGet = function () {
  var req = MockAxios.lastReqGet();
  return req ? req.promise : void 0;
};

MockAxios.reset = function () {
  // remove all the requests
  _pending_requests.splice(0, _pending_requests.length); // resets all information stored in the mockFn.mock.calls and mockFn.mock.instances arrays


  MockAxios.get.mockClear();
  MockAxios.post.mockClear();
  MockAxios.put.mockClear();
  MockAxios.patch.mockClear();
  MockAxios.delete.mockClear();
  MockAxios.head.mockClear();
  MockAxios.options.mockClear();
  MockAxios.all.mockClear();
}; // this is a singleton object


var _default = MockAxios;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9tb2NrLWF4aW9zLnRzIl0sIm5hbWVzIjpbIl9wZW5kaW5nX3JlcXVlc3RzIiwiX25ld1JlcSIsInVybCIsImRhdGEiLCJjb25maWciLCJwcm9taXNlIiwiU3luY1Byb21pc2UiLCJwdXNoIiwiTW9ja0F4aW9zIiwiamVzdCIsImZuIiwiZ2V0IiwicG9zdCIsInB1dCIsInBhdGNoIiwiZGVsZXRlIiwiYWxsIiwidmFsdWVzIiwiUHJvbWlzZSIsImhlYWQiLCJvcHRpb25zIiwiY3JlYXRlIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsInJlc3BvbnNlIiwicG9wUHJvbWlzZSIsIml4IiwibGVuZ3RoIiwicmVxIiwic3BsaWNlIiwic2hpZnQiLCJwb3BSZXF1ZXN0IiwiaW5kZXhPZiIsInBvcFF1ZXVlSXRlbSIsInF1ZXVlSXRlbSIsIm1vY2tSZXNwb25zZSIsIk9iamVjdCIsImFzc2lnbiIsImhlYWRlcnMiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwicmVzb2x2ZSIsIm1vY2tFcnJvciIsImVycm9yIiwicmVqZWN0IiwibGFzdFJlcUdldCIsImxhc3RQcm9taXNlR2V0IiwicmVzZXQiLCJtb2NrQ2xlYXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFRQTs7OztBQVJBOzs7Ozs7OztBQVdBO0FBQ0EsSUFBTUEsaUJBQXVDLEdBQUcsRUFBaEQ7O0FBRUEsSUFBTUMsT0FBK0QsR0FBRyxTQUFsRUEsT0FBa0UsQ0FBQ0MsR0FBRCxFQUFjQyxJQUFkLEVBQTBCQyxNQUExQixFQUEyQztBQUNqSCxNQUFNQyxPQUFvQixHQUFHLElBQUlDLHdCQUFKLEVBQTdCOztBQUNBTixFQUFBQSxpQkFBaUIsQ0FBQ08sSUFBbEIsQ0FBdUI7QUFDckJILElBQUFBLE1BQU0sRUFBTkEsTUFEcUI7QUFFckJELElBQUFBLElBQUksRUFBSkEsSUFGcUI7QUFHckJFLElBQUFBLE9BQU8sRUFBUEEsT0FIcUI7QUFJckJILElBQUFBLEdBQUcsRUFBSEE7QUFKcUIsR0FB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LEdBQTJCLENBQTVCLENBQXhCO0FBQ0QsQ0FGRDs7QUFJQXBCLFNBQVMsQ0FBQ3VDLGNBQVYsR0FBMkIsWUFBTTtBQUMvQixNQUFNbEIsR0FBRyxHQUFHckIsU0FBUyxDQUFDc0MsVUFBVixFQUFaO0FBQ0EsU0FBT2pCLEdBQUcsR0FBR0EsR0FBRyxDQUFDeEIsT0FBUCxHQUFpQixLQUFLLENBQWhDO0FBQ0QsQ0FIRDs7QUFLQUcsU0FBUyxDQUFDd0MsS0FBVixHQUFrQixZQUFNO0FBQ3RCO0FBQ0FoRCxFQUFBQSxpQkFBaUIsQ0FBQzhCLE1BQWxCLENBQXlCLENBQXpCLEVBQTRCOUIsaUJBQWlCLENBQUM0QixNQUE5QyxFQUZzQixDQUl0Qjs7O0FBQ0FwQixFQUFBQSxTQUFTLENBQUNHLEdBQVYsQ0FBY3NDLFNBQWQ7QUFDQXpDLEVBQUFBLFNBQVMsQ0FBQ0ksSUFBVixDQUFlcUMsU0FBZjtBQUNBekMsRUFBQUEsU0FBUyxDQUFDSyxHQUFWLENBQWNvQyxTQUFkO0FBQ0F6QyxFQUFBQSxTQUFTLENBQUNNLEtBQVYsQ0FBZ0JtQyxTQUFoQjtBQUNBekMsRUFBQUEsU0FBUyxDQUFDTyxNQUFWLENBQWlCa0MsU0FBakI7QUFDQXpDLEVBQUFBLFNBQVMsQ0FBQ1csSUFBVixDQUFlOEIsU0FBZjtBQUNBekMsRUFBQUEsU0FBUyxDQUFDWSxPQUFWLENBQWtCNkIsU0FBbEI7QUFDQXpDLEVBQUFBLFNBQVMsQ0FBQ1EsR0FBVixDQUFjaUMsU0FBZDtBQUNELENBYkQsQyxDQWVBOzs7ZUFDZXpDLFMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVHlwZVNjcmlwdCB2ZXJzaW9uIG9mIEF4aW9zIG1vY2sgZm9yIHVuaXQgdGVzdGluZyB3aXRoIFtKZXN0XShodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9qZXN0LykuXHJcbiAqIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90dXg0LzM2MDA2YTE4NTkzMjNmNzc5YWIwXHJcbiAqXHJcbiAqIEBhdXRob3IgICBrbmVlLWNvbGEgPG5pa29sYS5kZXJlemljQGdtYWlsLmNvbT5cclxuICogQGxpY2Vuc2UgIEBsaWNlbnNlIE1JVCBMaWNlbnNlLCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4gKi9cclxuXHJcbmltcG9ydCBTeW5jUHJvbWlzZSBmcm9tIFwiamVzdC1tb2NrLXByb21pc2VcIjtcclxuaW1wb3J0IHsgQW55RnVuY3Rpb24sIEF4aW9zTW9ja1F1ZXVlSXRlbSwgQXhpb3NNb2NrVHlwZSwgSHR0cFJlc3BvbnNlLCBTcHlGbiB9IGZyb20gXCIuL21vY2stYXhpb3MtdHlwZXNcIjtcclxuXHJcbi8qKiBhIEZJRk8gcXVldWUgb2YgcGVuZGluZyByZXF1ZXN0ICovXHJcbmNvbnN0IF9wZW5kaW5nX3JlcXVlc3RzOiBBeGlvc01vY2tRdWV1ZUl0ZW1bXSA9IFtdO1xyXG5cclxuY29uc3QgX25ld1JlcTogKHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBjb25maWc/OiBhbnkpID0+IFN5bmNQcm9taXNlID0gKHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBjb25maWc/OiBhbnkpID0+IHtcclxuICBjb25zdCBwcm9taXNlOiBTeW5jUHJvbWlzZSA9IG5ldyBTeW5jUHJvbWlzZSgpO1xyXG4gIF9wZW5kaW5nX3JlcXVlc3RzLnB1c2goe1xyXG4gICAgY29uZmlnLFxyXG4gICAgZGF0YSxcclxuICAgIHByb21pc2UsXHJcbiAgICB1cmwsXHJcbiAgfSk7XHJcbiAgcmV0dXJuKHByb21pc2UpO1xyXG59O1xyXG5cclxuY29uc3QgTW9ja0F4aW9zOiBBeGlvc01vY2tUeXBlID0gamVzdC5mbihfbmV3UmVxKSBhcyB1bmtub3duIGFzIEF4aW9zTW9ja1R5cGU7XHJcblxyXG4vLyBtb2NraW5nIEF4aW9zIG1ldGhvZHNcclxuTW9ja0F4aW9zLmdldCA9IGplc3QuZm4oX25ld1JlcSk7XHJcbk1vY2tBeGlvcy5wb3N0ID0gamVzdC5mbihfbmV3UmVxKTtcclxuTW9ja0F4aW9zLnB1dCA9IGplc3QuZm4oX25ld1JlcSk7XHJcbk1vY2tBeGlvcy5wYXRjaCA9IGplc3QuZm4oX25ld1JlcSk7XHJcbk1vY2tBeGlvcy5kZWxldGUgPSBqZXN0LmZuKF9uZXdSZXEpO1xyXG5Nb2NrQXhpb3MuYWxsID0gamVzdC5mbigodmFsdWVzKSA9PiBQcm9taXNlLmFsbCh2YWx1ZXMpKTtcclxuTW9ja0F4aW9zLmhlYWQgPSBqZXN0LmZuKF9uZXdSZXEpO1xyXG5Nb2NrQXhpb3Mub3B0aW9ucyA9IGplc3QuZm4oX25ld1JlcSk7XHJcbk1vY2tBeGlvcy5jcmVhdGUgPSBqZXN0LmZuKCgpID0+IE1vY2tBeGlvcyk7XHJcblxyXG5Nb2NrQXhpb3MuaW50ZXJjZXB0b3JzID0ge1xyXG4gIHJlcXVlc3Q6IHtcclxuICAgIHVzZTogamVzdC5mbigpXHJcbiAgfSxcclxuICByZXNwb25zZToge1xyXG4gICAgdXNlOiBqZXN0LmZuKClcclxuICB9XHJcbn1cclxuXHJcbk1vY2tBeGlvcy5wb3BQcm9taXNlID0gKHByb21pc2U/OiBTeW5jUHJvbWlzZSkgPT4ge1xyXG5cclxuICBpZiAocHJvbWlzZSkge1xyXG4gICAgLy8gcmVtb3ZlIHRoZSBwcm9taXNlIGZyb20gcGVuZGluZyBxdWV1ZVxyXG4gICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IF9wZW5kaW5nX3JlcXVlc3RzLmxlbmd0aDsgaXgrKykge1xyXG5cclxuICAgICAgY29uc3QgcmVxOiBBeGlvc01vY2tRdWV1ZUl0ZW0gPSBfcGVuZGluZ19yZXF1ZXN0c1tpeF07XHJcblxyXG4gICAgICBpZiAocmVxLnByb21pc2UgPT09IHByb21pc2UpIHtcclxuICAgICAgICBfcGVuZGluZ19yZXF1ZXN0cy5zcGxpY2UoaXgsIDEpO1xyXG4gICAgICAgIHJldHVybihyZXEucHJvbWlzZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHRha2UgdGhlIG9sZGVzdCBwcm9taXNlXHJcbiAgICBjb25zdCByZXE6IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IF9wZW5kaW5nX3JlcXVlc3RzLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4ocmVxID8gcmVxLnByb21pc2UgOiB2b2lkIDApO1xyXG4gIH1cclxufTtcclxuXHJcbk1vY2tBeGlvcy5wb3BSZXF1ZXN0ID0gKHJlcXVlc3Q/OiBBeGlvc01vY2tRdWV1ZUl0ZW0pID0+IHtcclxuXHJcbiAgaWYgKHJlcXVlc3QpIHtcclxuICAgIGNvbnN0IGl4ID0gX3BlbmRpbmdfcmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KTtcclxuICAgIGlmIChpeCA9PT0gLTEpIHtcclxuICAgICAgcmV0dXJuKHZvaWQgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKGl4LCAxKTtcclxuICAgIHJldHVybihyZXF1ZXN0KTtcclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybihfcGVuZGluZ19yZXF1ZXN0cy5zaGlmdCgpKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbiBpdGVtIGZvcm0gdGhlIHF1ZXVlLCBiYXNlZCBvbiBpdCdzIHR5cGVcclxuICogQHBhcmFtIHF1ZXVlSXRlbVxyXG4gKi9cclxuY29uc3QgcG9wUXVldWVJdGVtID0gKHF1ZXVlSXRlbTogU3luY1Byb21pc2V8QXhpb3NNb2NrUXVldWVJdGVtPSBudWxsKSA9PiB7XHJcbiAgLy8gZmlyc3QgbGUndCBwcmV0ZW5kIHRoZSBwYXJhbSBpcyBhIHF1ZXVlIGl0ZW1cclxuICBjb25zdCByZXF1ZXN0OiBBeGlvc01vY2tRdWV1ZUl0ZW0gPSBNb2NrQXhpb3MucG9wUmVxdWVzdChxdWV1ZUl0ZW0gYXMgQXhpb3NNb2NrUXVldWVJdGVtKTtcclxuXHJcbiAgaWYgKHJlcXVlc3QpIHtcclxuICAvLyBJRiB0aGUgcmVxdWVzdCB3YXMgZm91bmRcclxuICAvLyA+IHNldCB0aGUgcHJvbWlzZVxyXG4gICAgcmV0dXJuKHJlcXVlc3QucHJvbWlzZSk7XHJcbiAgfSBlbHNlIHtcclxuICAvLyBFTFNFIG1heWJlIHRoZSBgcXVldWVJdGVtYCBpcyBhIHByb21pc2UgKGxlZ2FjeSBtb2RlKVxyXG4gICAgcmV0dXJuKE1vY2tBeGlvcy5wb3BQcm9taXNlKHF1ZXVlSXRlbSBhcyBTeW5jUHJvbWlzZSkpO1xyXG4gIH1cclxufTtcclxuXHJcbk1vY2tBeGlvcy5tb2NrUmVzcG9uc2UgPSAocmVzcG9uc2U/OiBIdHRwUmVzcG9uc2UsIHF1ZXVlSXRlbTogU3luY1Byb21pc2V8QXhpb3NNb2NrUXVldWVJdGVtPSBudWxsKTogdm9pZCA9PiB7XHJcblxyXG4gIC8vIHJlcGxhY2luZyBtaXNzaW5nIGRhdGEgd2l0aCBkZWZhdWx0IHZhbHVlc1xyXG4gIHJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICBjb25maWc6IHt9LFxyXG4gICAgZGF0YToge30sXHJcbiAgICBoZWFkZXJzOiB7fSxcclxuICAgIHN0YXR1czogMjAwLFxyXG4gICAgc3RhdHVzVGV4dDogXCJPS1wiLFxyXG4gIH0sIHJlc3BvbnNlKTtcclxuXHJcbiAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlc3BvbnNlIGRhdGFcclxuICBwb3BRdWV1ZUl0ZW0ocXVldWVJdGVtKS5yZXNvbHZlKHJlc3BvbnNlKTtcclxufTtcclxuXHJcbk1vY2tBeGlvcy5tb2NrRXJyb3IgPSAoZXJyb3I6IGFueT0ge30sIHF1ZXVlSXRlbTogU3luY1Byb21pc2V8QXhpb3NNb2NrUXVldWVJdGVtPSBudWxsKSA9PiB7XHJcbiAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlc3BvbnNlIGRhdGFcclxuICBwb3BRdWV1ZUl0ZW0ocXVldWVJdGVtKS5yZWplY3QoT2JqZWN0LmFzc2lnbih7fSwgZXJyb3IpKTtcclxufTtcclxuXHJcbk1vY2tBeGlvcy5sYXN0UmVxR2V0ID0gKCkgPT4ge1xyXG4gIHJldHVybihfcGVuZGluZ19yZXF1ZXN0c1tfcGVuZGluZ19yZXF1ZXN0cy5sZW5ndGggLSAxXSk7XHJcbn07XHJcblxyXG5Nb2NrQXhpb3MubGFzdFByb21pc2VHZXQgPSAoKSA9PiB7XHJcbiAgY29uc3QgcmVxID0gTW9ja0F4aW9zLmxhc3RSZXFHZXQoKTtcclxuICByZXR1cm4ocmVxID8gcmVxLnByb21pc2UgOiB2b2lkIDApO1xyXG59O1xyXG5cclxuTW9ja0F4aW9zLnJlc2V0ID0gKCkgPT4ge1xyXG4gIC8vIHJlbW92ZSBhbGwgdGhlIHJlcXVlc3RzXHJcbiAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKDAsIF9wZW5kaW5nX3JlcXVlc3RzLmxlbmd0aCk7XHJcblxyXG4gIC8vIHJlc2V0cyBhbGwgaW5mb3JtYXRpb24gc3RvcmVkIGluIHRoZSBtb2NrRm4ubW9jay5jYWxscyBhbmQgbW9ja0ZuLm1vY2suaW5zdGFuY2VzIGFycmF5c1xyXG4gIE1vY2tBeGlvcy5nZXQubW9ja0NsZWFyKCk7XHJcbiAgTW9ja0F4aW9zLnBvc3QubW9ja0NsZWFyKCk7XHJcbiAgTW9ja0F4aW9zLnB1dC5tb2NrQ2xlYXIoKTtcclxuICBNb2NrQXhpb3MucGF0Y2gubW9ja0NsZWFyKCk7XHJcbiAgTW9ja0F4aW9zLmRlbGV0ZS5tb2NrQ2xlYXIoKTtcclxuICBNb2NrQXhpb3MuaGVhZC5tb2NrQ2xlYXIoKTtcclxuICBNb2NrQXhpb3Mub3B0aW9ucy5tb2NrQ2xlYXIoKTtcclxuICBNb2NrQXhpb3MuYWxsLm1vY2tDbGVhcigpO1xyXG59O1xyXG5cclxuLy8gdGhpcyBpcyBhIHNpbmdsZXRvbiBvYmplY3RcclxuZXhwb3J0IGRlZmF1bHQgTW9ja0F4aW9zO1xyXG4iXX0=